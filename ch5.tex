The Analysis Grand Challenge (AGC) is an analysis on top quark production meant to showcase an end-to-end analysis pipeline. Developed and organized by Iris-HEP, the AGC has several versions that showcase different cyber infrastructure and workflows, making it a great benchmark to test RNTuple. This section will describe the development of two new AGC versions that use ATLAS Open Data and RDataFrame: TTree and RNTuple versions. These versions were heavily influenced on the existing RDataFrame AGC repository that applies CMS open data and the uproot AGC repository that uses ATLAS Open Data. The full implementations of the AGC can be found in \cite{Rodriguez_2025_RNTupleWorkflow}. 

\section{RDataFrame Analysis Workflow}
The AGC is divided into two parts: an analysis script and a statistical script, both written in Python. The analysis scripts uses RDataFrame to apply preselections and output histograms of the top quark mass and the scalar sum of the transverse momenta, $H_T$, into a ROOT file. The statistical script performs a simple statistical analysis using the output ROOT file from the analysis script.

The inputs used for the AGC are the same 92 ROOT file from ATLAS Open Data, as described in \ref{sec:opendata}. Specifically, there are 22 single top samples, 10 $t\overline{t}$ samples, and 60 W+jets samples.

\subsection{Event Selections}
To reconstruct the top quark mass, events are selected from top quark pair production with final states that include a single charged lepton corresponding to the signature of semileptonic $t\overline{t}$ events, as shown in Figure \ref{fig:ttbar}. The leptons must have $p_t$ larger than 30 GeV and $|\eta|$ less than 2.1 events must include four jets, with two of the four being b-tagged. The other two jets are from the W boson decay. The top mass observable is then reconstructed by taking the invariant mass of the trijet with the largest transverse momentum, $p_t$. To plot the $H_T$ observable, the selected events must have at least one b-tagged jet among the four jets and exactly one lepton.
\begin{figure}[ht]
\centerline{\includegraphics[height=95mm]{ch6_images/ttbar.png}}
\caption[Top and Anti-top Quark Collision]{The schematic view of a top and anti-top quark collision \cite{Held_2022_PyHEP2022_AGC_talk}}
\label{fig:ttbar}
\end{figure}

The results of the newly developed AGC using ATLAS Open Data are shown in Figures \ref{fig:top-mass} and \ref{fig:Ht}. Both the RNTuple and TTree versions produced the same output, confirming that analysis performed in RDataFrame using RNTuple will remain largely unmodified. As previously mentioned, RNTuple only changes the structure of variable field names; therefore, alias variable names were applied to both TTree and RNTuple versions for consistency. 
\begin{figure}[ht]
\centerline{\includegraphics[height=95mm]{ch6_images/trijet_mass_prefit-2.pdf}}
\caption[The Trijet Mass Prefit]{The trijet mass prefit. This result is the same for both RNTuple and TTree versions of the AGC.}
\label{fig:top-mass}
\end{figure}

\begin{figure}[ht]
\centerline{\includegraphics[height=95mm]{ch6_images/Ht_prefit-3.pdf}}
\caption[Ht]{The $H_T$ observable prefit. This result is the same for both RNTuple and TTree versions of the AGC.}
\label{fig:Ht}
\end{figure}

\section{AGC Performance Studies}
A performance study evaluating execution speed and memory usage was conducted for both TTree and RNTuple versions of the AGC. Total execution times were measured 100 times for each version using the Python \emph{time} library. Both versions used inputs produced with the ZSTD compression algorithm. As shown in Figure \ref{fig:AGC-time}, RNTuple averaged 47.58 seconds to produce the top quark mass and $H_T$ histograms into a ROOT file, while TTree averaged 71.75 seconds. RNTuple was approximately 1.51 times faster, consistent with previous time measurements shown in Chapter \ref{fourthchapter}. The execution times were then remeasured using RNTuples produced with the LZ4 compression algorithm. As shown in Figure \ref{fig:AGC-LZ4}, LZ4 yields a slight improvement on the order of a few seconds, which is also consistent with previous results. Peak memory usage was measured using the inputs produces with ZSTD and with \texttt{/usr/bin/time}. As shown in Figure \ref{fig:memory-AGC}, RNTuple consumes slightly less memory usage than TTree when executing the AGC analysis script.
\begin{figure}[ht]
\centerline{\includegraphics[height=95mm]{ch6_images/TimeDistribution.png}}
\caption[Distribution of AGC Execution Times]{The total execution times of the AGC measured 100 times for TTree and RNTuple versions.}
\label{fig:AGC-time}
\end{figure}

\begin{figure}[ht]
\centerline{\includegraphics[height=95mm]{ch6_images/TimeDistribution_LZ4.png}}
\caption[Distribution of AGC Execution Times using LZ4 Inputs]{The total execution times of the AGC measured 100 times with RNTuples produced with the LZ4 compression algorithm.}
\label{fig:AGC-LZ4}
\end{figure}

\begin{figure}[ht]
\centerline{\includegraphics[height=95mm]{ch6_images/memory_histogram.png}}
\caption[AGC Peak Memory Usage]{The peak memory usage when executing the AGC.}
\label{fig:memory-AGC}
\end{figure}



